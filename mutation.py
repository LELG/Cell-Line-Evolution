"""
Module for class representing mutations,
and associated functions.
"""
from __future__ import print_function
from ast import literal_eval
import math
import numpy as np
import random


class Mutation(object):
    """
    Class to represent mutations.
    """
    # a counter of how many mutations have been created.
    # Used to assign unique IDs to mutations.
    num_muts_created = 0

    def __init__(self, opt, t_curr, all_muts, from_file=False):
        """Create new mutation"""
        # assign ID and increment object counter
        self.mut_id = self.__class__.num_muts_created
        self.__class__.num_muts_created += 1

        self.s_time = t_curr

        if not from_file:
            # get proliferation rate effect and mutation type
            self.prolif_rate_effect = get_prolif_rate_mutn(opt)
            if self.prolif_rate_effect == 0.0:
                self.mut_type = 'n'
            elif self.prolif_rate_effect > 0.0:
                self.mut_type = 'b'
            else:
                self.mut_type = 'd'

            # get mutation rate effect - this does not
            # affect mutation type
            self.mut_rate_effect = get_mut_rate_mutn(opt)

            # assume that all_muts is a dictionary with
            # keys for each mutation type
            try:
                all_muts[self.mut_type].append(self)
            except KeyError:
                raise
        # mutation is being initialised from file
        else:
            self.prolif_rate_effect = self.mut_rate_effect = None
            self.mut_type = None
            # this var will be used to associate the
            # mutation with its original clone
            self.original_clone_id = None

        self.original_clone = None
        self.resist_strength = None

    @classmethod
    def init_from_file(cls, opt, all_muts, attr_dict):
        """Load an individual mutation from a population snapshot.

        Input
        -----
        cls: Mutation or one of its subclasses
        opt: set of global parameters, used to initialise mutation
        all_muts: dictionary of all mutations in this simulation
        attr_dict: a dictionary of attributes generated by a DictReader
                   processing a stored population CSV file.

        Returns
        -------
        A new Mutation with attributes determined by attr_dict
        """
        # initialise new mutation object
        new_mut = cls(opt, 0, all_muts, from_file=True)

        # Update attributes from file.
        # Only update attributes that the mutation already has,
        # to prevent bad input from CSV file
        for attr in attr_dict:
            if hasattr(new_mut, attr):
                setattr(new_mut, attr, literal_eval(attr_dict[attr]))
            else:
                raise Exception("attempting to set invalid attribute for subpop: {}".format(attr))

        # insert mutation into all_muts dictionary,
        # assuming that all_muts has keys for each
        # valid mutation type, and values as lists of mutations
        try:
            all_muts[new_mut.mut_type].append(new_mut)
        except KeyError:
            raise

        return new_mut

    def switch_mutn_type(self, all_muts, new_mut_type):
        """Change the mutation type of this mutation."""
        try:
            all_muts[self.mut_type].remove(self)
        except ValueError:
            raise ValueError("Mutn not in all_muts[{}]".format(self.mut_type))
        try:
            all_muts[new_mut_type].append(self)
        except KeyError:
            raise
        self.mut_type = new_mut_type

    def become_resistant(self, all_muts, resist_strength):
        """Make this mutation a resistance mutation."""
        # switch which sublist this mutation appears in
        self.original_clone.switch_mutn_type(self, 'r')
        self.switch_mutn_type(all_muts, 'r')
        self.resist_strength = resist_strength
        self.original_clone.become_resistant(self.resist_strength)


def mutn_effect_size_from_beta_dist():
    """Use beta distribution to get random mutation effect size."""
    return np.random.beta(1, 3)


def get_prolif_rate_mutn(opt):
    """Generate a proliferation rate mutation effect."""
    scale_factor = opt.scale * opt.pro
    prolif_rate_effect = get_mutn_effect(scale_factor, opt.prob_mut_pos,
                                         opt.prob_mut_neg)
    return prolif_rate_effect


def get_mut_rate_mutn(opt):
    """Generate a mutation rate mutation effect."""
    scale_factor = opt.mscale * opt.mut
    mut_rate_effect = get_mutn_effect(scale_factor, opt.prob_inc_mut,
                                      opt.prob_dec_mut)
    return mut_rate_effect


def get_mutn_effect(scale_factor, prob_pos, prob_neg, get_effect_size=mutn_effect_size_from_beta_dist):
    """Get a mutation effect size and type.

    Note that `get_effect_size` must be a function
    which samples from a suitable probability distribution.
    """
    # get a random effect size from a suitable probability
    # distribution, and scale as necessary
    mutn_magnitude = get_effect_size() * scale_factor

    # random.random generates a uniform pseudo-random float
    # between 0 and 1; by subtracting the probability
    # of a negative mutation from this float, we get
    # a float with `prob_neg` chance of being < 0
    # and `1 - prob_neg` chance of being > 0
    # (which could be beneficial or neutral)
    mut_type_from_sign = random.random() - prob_neg

    # allow for the possibility that there is a non-zero
    # chance of a 'strictly' neutral mutation
    prob_neutral_mut = (1 - prob_pos - prob_neg)
    if 0.0 <= mut_type_from_sign < prob_neutral_mut:
        mutn_magnitude = 0.0

    # now we copy the sign of this random float (our
    # mutation 'type') to the effect size we got from
    # the random distribution
    mutn_effect = math.copysign(mutn_magnitude, mut_type_from_sign)

    return mutn_effect


def generate_resistance(all_mutations, tumoursize, deterministic_num_r_muts, resist_strength=1.0):
    """Trigger the creation of resistance mutations."""
    # first, prune any mutations no longer present in the population
    all_muts_flat = sum(all_mutations.values(), [])
    all_mutations['dead'] = []
    for mut in all_muts_flat:
        if mut.original_clone.is_dead_end():
            mut.switch_mutn_type(all_mutations, 'dead')

    # create flat list of deleterious/neutral mutations
    del_neutr_mutns = all_mutations['d'] + all_mutations['n']

    if deterministic_num_r_muts >= 0:
        num_resist_mutns = deterministic_num_r_muts
    else:
        num_resist_mutns = get_rand_num_r_mutns(len(del_neutr_mutns), tumoursize)

    # random.sample() returns a list of num_resist_mutns mutations,
    # randomly selected from del_neutr_mutns (with uniform likelihood)
    resistance_mutns = random.sample(del_neutr_mutns, num_resist_mutns)

    for mutn in resistance_mutns:
        mutn.become_resistant(all_mutations, resist_strength)

    print("{} resistance mutations generated.".format(num_resist_mutns))


def get_rand_num_r_mutns(total_mutns, tumoursize, min_resistant_pop_size=1e6):
    """Get a random number of resistance mutations for a given population."""
    prob_single_resist_mutn = tumoursize / float(min_resistant_pop_size)
    prob_resistance_mutn = prob_single_resist_mutn / float(total_mutns)
    num_resist_mutns = np.random.binomial(total_mutns, prob_resistance_mutn)
    return num_resist_mutns
